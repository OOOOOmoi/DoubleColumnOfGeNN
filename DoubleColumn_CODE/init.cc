#include "definitionsInternal.h"
#include <iostream>
#include <random>
#include <cstdint>

struct MergedNeuronInitGroup0
 {
    float* inSynInSyn3;
    unsigned int* denDelayPtrInSyn7;
    float* denDelayInSyn7;
    float* inSynInSyn7;
    unsigned int* denDelayPtrInSyn6;
    float* denDelayInSyn6;
    float* inSynInSyn6;
    unsigned int* denDelayPtrInSyn5;
    float* denDelayInSyn5;
    float* inSynInSyn5;
    unsigned int* denDelayPtrInSyn4;
    float* denDelayInSyn4;
    float* inSynInSyn4;
    unsigned int* denDelayPtrInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn2;
    float* denDelayInSyn2;
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn1;
    unsigned int* denDelayPtrInSyn0;
    float* denDelayInSyn0;
    float* inSynInSyn0;
    scalar* RefracTime;
    scalar* V;
    unsigned int* spk;
    unsigned int* spkCnt;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup1
 {
    unsigned int* denDelayPtrInSyn2;
    unsigned int* denDelayPtrInSyn6;
    float* denDelayInSyn6;
    float* inSynInSyn6;
    unsigned int* denDelayPtrInSyn5;
    float* denDelayInSyn5;
    float* inSynInSyn5;
    unsigned int* denDelayPtrInSyn4;
    float* denDelayInSyn4;
    float* inSynInSyn4;
    unsigned int* denDelayPtrInSyn3;
    float* denDelayInSyn3;
    float* inSynInSyn3;
    float* denDelayInSyn2;
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn1;
    unsigned int* denDelayPtrInSyn0;
    float* denDelayInSyn0;
    float* inSynInSyn0;
    scalar* RefracTime;
    scalar* V;
    unsigned int* spk;
    unsigned int* spkCnt;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup2
 {
    float* denDelayInSyn12;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    unsigned int* denDelayPtrInSyn7;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn13;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    float* inSynInSyn14;
    float* denDelayInSyn14;
    unsigned int* denDelayPtrInSyn14;
    float* inSynInSyn15;
    float* denDelayInSyn15;
    unsigned int* denDelayPtrInSyn15;
    float* inSynInSyn16;
    float* denDelayInSyn16;
    unsigned int* denDelayPtrInSyn16;
    float* inSynInSyn3;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup3
 {
    float* inSynInSyn10;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn6;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn13;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    float* denDelayInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup4
 {
    unsigned int* denDelayPtrInSyn3;
    unsigned int* denDelayPtrInSyn8;
    float* denDelayInSyn8;
    float* inSynInSyn8;
    unsigned int* denDelayPtrInSyn7;
    float* denDelayInSyn7;
    float* inSynInSyn7;
    unsigned int* denDelayPtrInSyn6;
    float* denDelayInSyn6;
    float* inSynInSyn6;
    unsigned int* denDelayPtrInSyn5;
    float* denDelayInSyn5;
    float* inSynInSyn5;
    unsigned int* denDelayPtrInSyn4;
    float* denDelayInSyn4;
    float* inSynInSyn4;
    float* denDelayInSyn3;
    float* inSynInSyn3;
    unsigned int* denDelayPtrInSyn2;
    float* denDelayInSyn2;
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn1;
    unsigned int* denDelayPtrInSyn0;
    float* denDelayInSyn0;
    float* inSynInSyn0;
    scalar* RefracTime;
    scalar* V;
    unsigned int* spk;
    unsigned int* spkCnt;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup5
 {
    float* denDelayInSyn9;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    unsigned int* denDelayPtrInSyn5;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup6
 {
    unsigned int* denDelayPtrInSyn8;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    float* inSynInSyn5;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    unsigned int* denDelayPtrInSyn1;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup7
 {
    float* inSynInSyn8;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    unsigned int* denDelayPtrInSyn4;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    unsigned int* denDelayPtrInSyn1;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup8
 {
    unsigned int* denDelayPtrInSyn11;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    float* inSynInSyn7;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn13;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    float* inSynInSyn14;
    float* denDelayInSyn14;
    unsigned int* denDelayPtrInSyn14;
    float* inSynInSyn15;
    float* denDelayInSyn15;
    unsigned int* denDelayPtrInSyn15;
    unsigned int* denDelayPtrInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup9
 {
    float* inSynInSyn13;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn8;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    float* inSynInSyn14;
    float* denDelayInSyn14;
    unsigned int* denDelayPtrInSyn14;
    float* inSynInSyn15;
    float* denDelayInSyn15;
    unsigned int* denDelayPtrInSyn15;
    float* inSynInSyn16;
    float* denDelayInSyn16;
    unsigned int* denDelayPtrInSyn16;
    float* inSynInSyn17;
    float* denDelayInSyn17;
    unsigned int* denDelayPtrInSyn17;
    float* denDelayInSyn3;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup10
 {
    float* inSynInSyn11;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    unsigned int* denDelayPtrInSyn6;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn13;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    float* inSynInSyn14;
    float* denDelayInSyn14;
    unsigned int* denDelayPtrInSyn14;
    unsigned int* denDelayPtrInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int numNeurons;
    
}
;
struct MergedSynapseConnectivityInitGroup0
 {
    unsigned int* rowLength;
    uint32_t* ind;
    uint16_t* preCalcRowLength;
    unsigned int numSrcNeurons;
    unsigned int numTrgNeurons;
    unsigned int rowStride;
    
}
;
struct MergedSynapseSparseInitGroup0
 {
    unsigned int* rowLength;
    uint32_t* ind;
    scalar* g;
    uint8_t* d;
    unsigned int numSrcNeurons;
    unsigned int numTrgNeurons;
    unsigned int rowStride;
    unsigned int colStride;
    scalar meang;
    scalar sdg;
    scalar meanTimestepd;
    scalar sdTimestepd;
    scalar maxTimestepd;
    
}
;
__device__ __constant__ MergedNeuronInitGroup0 d_mergedNeuronInitGroup0[2];
void pushMergedNeuronInitGroup0ToDevice(unsigned int idx, float* inSynInSyn3, unsigned int* denDelayPtrInSyn7, float* denDelayInSyn7, float* inSynInSyn7, unsigned int* denDelayPtrInSyn6, float* denDelayInSyn6, float* inSynInSyn6, unsigned int* denDelayPtrInSyn5, float* denDelayInSyn5, float* inSynInSyn5, unsigned int* denDelayPtrInSyn4, float* denDelayInSyn4, float* inSynInSyn4, unsigned int* denDelayPtrInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn2, float* denDelayInSyn2, float* inSynInSyn2, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn1, float* inSynInSyn1, unsigned int* denDelayPtrInSyn0, float* denDelayInSyn0, float* inSynInSyn0, scalar* RefracTime, scalar* V, unsigned int* spk, unsigned int* spkCnt, unsigned int numNeurons) {
    MergedNeuronInitGroup0 group = {inSynInSyn3, denDelayPtrInSyn7, denDelayInSyn7, inSynInSyn7, denDelayPtrInSyn6, denDelayInSyn6, inSynInSyn6, denDelayPtrInSyn5, denDelayInSyn5, inSynInSyn5, denDelayPtrInSyn4, denDelayInSyn4, inSynInSyn4, denDelayPtrInSyn3, denDelayInSyn3, denDelayPtrInSyn2, denDelayInSyn2, inSynInSyn2, denDelayPtrInSyn1, denDelayInSyn1, inSynInSyn1, denDelayPtrInSyn0, denDelayInSyn0, inSynInSyn0, RefracTime, V, spk, spkCnt, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup0, &group, sizeof(MergedNeuronInitGroup0), idx * sizeof(MergedNeuronInitGroup0)));
}
__device__ __constant__ MergedNeuronInitGroup1 d_mergedNeuronInitGroup1[1];
void pushMergedNeuronInitGroup1ToDevice(unsigned int idx, unsigned int* denDelayPtrInSyn2, unsigned int* denDelayPtrInSyn6, float* denDelayInSyn6, float* inSynInSyn6, unsigned int* denDelayPtrInSyn5, float* denDelayInSyn5, float* inSynInSyn5, unsigned int* denDelayPtrInSyn4, float* denDelayInSyn4, float* inSynInSyn4, unsigned int* denDelayPtrInSyn3, float* denDelayInSyn3, float* inSynInSyn3, float* denDelayInSyn2, float* inSynInSyn2, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn1, float* inSynInSyn1, unsigned int* denDelayPtrInSyn0, float* denDelayInSyn0, float* inSynInSyn0, scalar* RefracTime, scalar* V, unsigned int* spk, unsigned int* spkCnt, unsigned int numNeurons) {
    MergedNeuronInitGroup1 group = {denDelayPtrInSyn2, denDelayPtrInSyn6, denDelayInSyn6, inSynInSyn6, denDelayPtrInSyn5, denDelayInSyn5, inSynInSyn5, denDelayPtrInSyn4, denDelayInSyn4, inSynInSyn4, denDelayPtrInSyn3, denDelayInSyn3, inSynInSyn3, denDelayInSyn2, inSynInSyn2, denDelayPtrInSyn1, denDelayInSyn1, inSynInSyn1, denDelayPtrInSyn0, denDelayInSyn0, inSynInSyn0, RefracTime, V, spk, spkCnt, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup1, &group, sizeof(MergedNeuronInitGroup1), idx * sizeof(MergedNeuronInitGroup1)));
}
__device__ __constant__ MergedNeuronInitGroup2 d_mergedNeuronInitGroup2[1];
void pushMergedNeuronInitGroup2ToDevice(unsigned int idx, float* denDelayInSyn12, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, unsigned int* denDelayPtrInSyn7, unsigned int* denDelayPtrInSyn12, float* inSynInSyn13, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, float* inSynInSyn14, float* denDelayInSyn14, unsigned int* denDelayPtrInSyn14, float* inSynInSyn15, float* denDelayInSyn15, unsigned int* denDelayPtrInSyn15, float* inSynInSyn16, float* denDelayInSyn16, unsigned int* denDelayPtrInSyn16, float* inSynInSyn3, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int numNeurons) {
    MergedNeuronInitGroup2 group = {denDelayInSyn12, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayPtrInSyn7, denDelayPtrInSyn12, inSynInSyn13, denDelayInSyn13, denDelayPtrInSyn13, inSynInSyn14, denDelayInSyn14, denDelayPtrInSyn14, inSynInSyn15, denDelayInSyn15, denDelayPtrInSyn15, inSynInSyn16, denDelayInSyn16, denDelayPtrInSyn16, inSynInSyn3, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup2, &group, sizeof(MergedNeuronInitGroup2), idx * sizeof(MergedNeuronInitGroup2)));
}
__device__ __constant__ MergedNeuronInitGroup3 d_mergedNeuronInitGroup3[2];
void pushMergedNeuronInitGroup3ToDevice(unsigned int idx, float* inSynInSyn10, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn6, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn13, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, float* denDelayInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, unsigned int numNeurons) {
    MergedNeuronInitGroup3 group = {inSynInSyn10, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn6, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn13, denDelayInSyn13, denDelayPtrInSyn13, denDelayInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup3, &group, sizeof(MergedNeuronInitGroup3), idx * sizeof(MergedNeuronInitGroup3)));
}
__device__ __constant__ MergedNeuronInitGroup4 d_mergedNeuronInitGroup4[3];
void pushMergedNeuronInitGroup4ToDevice(unsigned int idx, unsigned int* denDelayPtrInSyn3, unsigned int* denDelayPtrInSyn8, float* denDelayInSyn8, float* inSynInSyn8, unsigned int* denDelayPtrInSyn7, float* denDelayInSyn7, float* inSynInSyn7, unsigned int* denDelayPtrInSyn6, float* denDelayInSyn6, float* inSynInSyn6, unsigned int* denDelayPtrInSyn5, float* denDelayInSyn5, float* inSynInSyn5, unsigned int* denDelayPtrInSyn4, float* denDelayInSyn4, float* inSynInSyn4, float* denDelayInSyn3, float* inSynInSyn3, unsigned int* denDelayPtrInSyn2, float* denDelayInSyn2, float* inSynInSyn2, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn1, float* inSynInSyn1, unsigned int* denDelayPtrInSyn0, float* denDelayInSyn0, float* inSynInSyn0, scalar* RefracTime, scalar* V, unsigned int* spk, unsigned int* spkCnt, unsigned int numNeurons) {
    MergedNeuronInitGroup4 group = {denDelayPtrInSyn3, denDelayPtrInSyn8, denDelayInSyn8, inSynInSyn8, denDelayPtrInSyn7, denDelayInSyn7, inSynInSyn7, denDelayPtrInSyn6, denDelayInSyn6, inSynInSyn6, denDelayPtrInSyn5, denDelayInSyn5, inSynInSyn5, denDelayPtrInSyn4, denDelayInSyn4, inSynInSyn4, denDelayInSyn3, inSynInSyn3, denDelayPtrInSyn2, denDelayInSyn2, inSynInSyn2, denDelayPtrInSyn1, denDelayInSyn1, inSynInSyn1, denDelayPtrInSyn0, denDelayInSyn0, inSynInSyn0, RefracTime, V, spk, spkCnt, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup4, &group, sizeof(MergedNeuronInitGroup4), idx * sizeof(MergedNeuronInitGroup4)));
}
__device__ __constant__ MergedNeuronInitGroup5 d_mergedNeuronInitGroup5[6];
void pushMergedNeuronInitGroup5ToDevice(unsigned int idx, float* denDelayInSyn9, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, unsigned int* denDelayPtrInSyn5, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int numNeurons) {
    MergedNeuronInitGroup5 group = {denDelayInSyn9, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayPtrInSyn5, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup5, &group, sizeof(MergedNeuronInitGroup5), idx * sizeof(MergedNeuronInitGroup5)));
}
__device__ __constant__ MergedNeuronInitGroup6 d_mergedNeuronInitGroup6[5];
void pushMergedNeuronInitGroup6ToDevice(unsigned int idx, unsigned int* denDelayPtrInSyn8, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, float* inSynInSyn5, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, unsigned int* denDelayPtrInSyn1, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, unsigned int numNeurons) {
    MergedNeuronInitGroup6 group = {denDelayPtrInSyn8, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, inSynInSyn5, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, denDelayPtrInSyn1, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup6, &group, sizeof(MergedNeuronInitGroup6), idx * sizeof(MergedNeuronInitGroup6)));
}
__device__ __constant__ MergedNeuronInitGroup7 d_mergedNeuronInitGroup7[6];
void pushMergedNeuronInitGroup7ToDevice(unsigned int idx, float* inSynInSyn8, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, unsigned int* denDelayPtrInSyn4, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, unsigned int* denDelayPtrInSyn1, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int numNeurons) {
    MergedNeuronInitGroup7 group = {inSynInSyn8, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, denDelayPtrInSyn4, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, denDelayPtrInSyn1, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup7, &group, sizeof(MergedNeuronInitGroup7), idx * sizeof(MergedNeuronInitGroup7)));
}
__device__ __constant__ MergedNeuronInitGroup8 d_mergedNeuronInitGroup8[2];
void pushMergedNeuronInitGroup8ToDevice(unsigned int idx, unsigned int* denDelayPtrInSyn11, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, float* inSynInSyn7, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn13, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, float* inSynInSyn14, float* denDelayInSyn14, unsigned int* denDelayPtrInSyn14, float* inSynInSyn15, float* denDelayInSyn15, unsigned int* denDelayPtrInSyn15, unsigned int* denDelayPtrInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, unsigned int numNeurons) {
    MergedNeuronInitGroup8 group = {denDelayPtrInSyn11, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, inSynInSyn7, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn13, denDelayInSyn13, denDelayPtrInSyn13, inSynInSyn14, denDelayInSyn14, denDelayPtrInSyn14, inSynInSyn15, denDelayInSyn15, denDelayPtrInSyn15, denDelayPtrInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup8, &group, sizeof(MergedNeuronInitGroup8), idx * sizeof(MergedNeuronInitGroup8)));
}
__device__ __constant__ MergedNeuronInitGroup9 d_mergedNeuronInitGroup9[1];
void pushMergedNeuronInitGroup9ToDevice(unsigned int idx, float* inSynInSyn13, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn8, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, float* inSynInSyn14, float* denDelayInSyn14, unsigned int* denDelayPtrInSyn14, float* inSynInSyn15, float* denDelayInSyn15, unsigned int* denDelayPtrInSyn15, float* inSynInSyn16, float* denDelayInSyn16, unsigned int* denDelayPtrInSyn16, float* inSynInSyn17, float* denDelayInSyn17, unsigned int* denDelayPtrInSyn17, float* denDelayInSyn3, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, unsigned int numNeurons) {
    MergedNeuronInitGroup9 group = {inSynInSyn13, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn8, denDelayInSyn13, denDelayPtrInSyn13, inSynInSyn14, denDelayInSyn14, denDelayPtrInSyn14, inSynInSyn15, denDelayInSyn15, denDelayPtrInSyn15, inSynInSyn16, denDelayInSyn16, denDelayPtrInSyn16, inSynInSyn17, denDelayInSyn17, denDelayPtrInSyn17, denDelayInSyn3, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup9, &group, sizeof(MergedNeuronInitGroup9), idx * sizeof(MergedNeuronInitGroup9)));
}
__device__ __constant__ MergedNeuronInitGroup10 d_mergedNeuronInitGroup10[5];
void pushMergedNeuronInitGroup10ToDevice(unsigned int idx, float* inSynInSyn11, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, unsigned int* denDelayPtrInSyn6, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn13, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, float* inSynInSyn14, float* denDelayInSyn14, unsigned int* denDelayPtrInSyn14, unsigned int* denDelayPtrInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int numNeurons) {
    MergedNeuronInitGroup10 group = {inSynInSyn11, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, denDelayPtrInSyn6, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn13, denDelayInSyn13, denDelayPtrInSyn13, inSynInSyn14, denDelayInSyn14, denDelayPtrInSyn14, denDelayPtrInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup10, &group, sizeof(MergedNeuronInitGroup10), idx * sizeof(MergedNeuronInitGroup10)));
}
__device__ MergedSynapseConnectivityInitGroup0 d_mergedSynapseConnectivityInitGroup0[424];
void pushMergedSynapseConnectivityInitGroup0ToDevice(unsigned int idx, unsigned int* rowLength, uint32_t* ind, uint16_t* preCalcRowLength, unsigned int numSrcNeurons, unsigned int numTrgNeurons, unsigned int rowStride) {
    MergedSynapseConnectivityInitGroup0 group = {rowLength, ind, preCalcRowLength, numSrcNeurons, numTrgNeurons, rowStride, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedSynapseConnectivityInitGroup0, &group, sizeof(MergedSynapseConnectivityInitGroup0), idx * sizeof(MergedSynapseConnectivityInitGroup0)));
}
__device__ MergedSynapseSparseInitGroup0 d_mergedSynapseSparseInitGroup0[424];
void pushMergedSynapseSparseInitGroup0ToDevice(unsigned int idx, unsigned int* rowLength, uint32_t* ind, scalar* g, uint8_t* d, unsigned int numSrcNeurons, unsigned int numTrgNeurons, unsigned int rowStride, unsigned int colStride, scalar meang, scalar sdg, scalar meanTimestepd, scalar sdTimestepd, scalar maxTimestepd) {
    MergedSynapseSparseInitGroup0 group = {rowLength, ind, g, d, numSrcNeurons, numTrgNeurons, rowStride, colStride, meang, sdg, meanTimestepd, sdTimestepd, maxTimestepd, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedSynapseSparseInitGroup0, &group, sizeof(MergedSynapseSparseInitGroup0), idx * sizeof(MergedSynapseSparseInitGroup0)));
}
// ------------------------------------------------------------------------
// merged extra global parameter functions
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// merged extra global parameter functions
// ------------------------------------------------------------------------
void pushMergedSynapseConnectivityInit0preCalcRowLengthToDevice(unsigned int idx, uint16_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedSynapseConnectivityInitGroup0, &value, sizeof(value), (sizeof(MergedSynapseConnectivityInitGroup0) * (idx)) + offsetof(MergedSynapseConnectivityInitGroup0, preCalcRowLength)));
}

// ------------------------------------------------------------------------
// merged extra global parameter functions
// ------------------------------------------------------------------------
__device__ unsigned int d_mergedNeuronInitGroupStartID0[] = {0, 1696, };
__device__ unsigned int d_mergedNeuronInitGroupStartID1[] = {3328, };
__device__ unsigned int d_mergedNeuronInitGroupStartID2[] = {16832, };
__device__ unsigned int d_mergedNeuronInitGroupStartID3[] = {18592, 21216, };
__device__ unsigned int d_mergedNeuronInitGroupStartID4[] = {60288, 75840, 77472, };
__device__ unsigned int d_mergedNeuronInitGroupStartID5[] = {77792, 98080, 102624, 157792, 161472, 162528, };
__device__ unsigned int d_mergedNeuronInitGroupStartID6[] = {162848, 166912, 168512, 171296, 173408, };
__device__ unsigned int d_mergedNeuronInitGroupStartID7[] = {174880, 176544, 178464, 178784, 198464, 200512, };
__device__ unsigned int d_mergedNeuronInitGroupStartID8[] = {205344, 280288, };
__device__ unsigned int d_mergedNeuronInitGroupStartID9[] = {300192, };
__device__ unsigned int d_mergedNeuronInitGroupStartID10[] = {321824, 373568, 380608, 382592, 382944, };
__device__ unsigned int d_mergedSynapseConnectivityInitGroupStartID0[] = {384576, 436320, 488064, 539808, 591552, 643296, 695040, 746784, 798528, 850272, 902016, 953760, 1005504, 1057248, 1108992, 1160736, 1212480, 1264224, 1315968, 1367712, 1419456, 1471200, 1522944, 1574688, 1626432, 1701376, 1776320, 1851264, 1926208, 2001152, 2076096, 2151040, 2225984, 2300928, 2375872, 2450816, 2525760, 2600704, 2622336, 2643968, 2665600, 2687232, 2708864, 2730496, 2752128, 2773760, 2795392, 2817024, 2838656, 2860288, 2881920, 2903552, 2925184, 2946816, 2968448, 2988736, 3009024, 3029312, 3049600, 3069888, 3090176, 3110464, 3130752, 3146304, 3161856, 3177408, 3192960, 3208512, 3224064, 3239616, 3255168, 3257792, 3260416, 3263040, 3265664, 3268288, 3270912, 3273536, 3276160, 3278784, 3281408, 3284032, 3291072, 3298112, 3305152, 3312192, 3319232, 3326272, 3333312, 3340352, 3347392, 3354432, 3361472, 3368512, 3370272, 3372032, 3373792, 3375552, 3377312, 3379072, 3380832, 3382592, 3384352, 3386112, 3387872, 3389632, 3391296, 3392960, 3394624, 3396288, 3397952, 3399616, 3401280, 3402944, 3404608, 3406272, 3408192, 3410112, 3412032, 3413952, 3415872, 3417792, 3419712, 3421632, 3423552, 3425472, 3429536, 3433600, 3437664, 3441728, 3445792, 3449856, 3453920, 3457984, 3462048, 3466112, 3470176, 3474240, 3475840, 3477440, 3479040, 3480640, 3482240, 3483840, 3485440, 3487040, 3488640, 3490240, 3491840, 3493440, 3495040, 3496640, 3498240, 3499936, 3501632, 3503328, 3505024, 3506720, 3508416, 3510112, 3511808, 3516352, 3520896, 3525440, 3529984, 3534528, 3539072, 3543616, 3548160, 3550144, 3552128, 3554112, 3556096, 3558080, 3560064, 3562048, 3564032, 3566016, 3568000, 3569984, 3570336, 3570688, 3571040, 3571392, 3571744, 3572096, 3572448, 3572800, 3573152, 3573504, 3573856, 3574208, 3574528, 3574848, 3575168, 3575488, 3575808, 3576128, 3576448, 3576768, 3631936, 3687104, 3742272, 3797440, 3852608, 3907776, 3962944, 4018112, 4073280, 4128448, 4183616, 4238784, 4293952, 4349120, 4404288, 4459456, 4514624, 4569792, 4624960, 4680128, 4735296, 4790464, 4845632, 4900800, 4939872, 4978944, 5018016, 5057088, 5096160, 5135232, 5174304, 5213376, 5252448, 5291520, 5330592, 5369664, 5408736, 5428640, 5448544, 5468448, 5488352, 5508256, 5528160, 5548064, 5567968, 5587872, 5607776, 5627680, 5647584, 5667488, 5687392, 5707296, 5727200, 5747104, 5767008, 5786912, 5806816, 5826720, 5846624, 5866528, 5886432, 5906336, 5926240, 5946144, 5966048, 5985952, 6005856, 6025536, 6045216, 6064896, 6084576, 6104256, 6123936, 6143616, 6163296, 6182976, 6202656, 6222336, 6242016, 6261696, 6281376, 6301056, 6320736, 6340416, 6360096, 6379776, 6399456, 6419136, 6432640, 6446144, 6459648, 6473152, 6486656, 6500160, 6513664, 6527168, 6529952, 6532736, 6535520, 6538304, 6541088, 6543872, 6546656, 6549440, 6552224, 6555008, 6557792, 6561472, 6565152, 6568832, 6572512, 6576192, 6579872, 6583552, 6587232, 6590912, 6594592, 6598272, 6601952, 6603584, 6605216, 6606848, 6608480, 6610112, 6611744, 6613376, 6615008, 6616640, 6618272, 6619904, 6621536, 6623168, 6624800, 6626432, 6628064, 6629696, 6631328, 6632960, 6634592, 6636224, 6637856, 6639904, 6641952, 6644000, 6646048, 6648096, 6650144, 6652192, 6654240, 6656288, 6658336, 6660448, 6662560, 6664672, 6666784, 6668896, 6671008, 6673120, 6675232, 6677344, 6679456, 6681568, 6683680, 6685152, 6686624, 6688096, 6689568, 6691040, 6692512, 6693984, 6695456, 6696928, 6698400, 6699872, 6701344, 6702816, 6704288, 6705760, 6707392, 6709024, 6710656, 6712288, 6713920, 6715552, 6717184, 6718816, 6723648, 6728480, 6733312, 6738144, 6742976, 6747808, 6752640, 6757472, 6758528, 6759584, 6760640, 6761696, 6762752, 6763808, 6764864, 6765920, 6766976, 6768032, 6769088, 6769408, 6769728, 6770048, 6770368, 6770688, 6771008, 6771328, 6771648, 6771968, 6772288, 6772608, 6772928, 6773248, 6773568, 6773888, 6774208, 6774528, 6774848, 6775168, };
__device__ unsigned int d_mergedSynapseSparseInitGroupStartID0[] = {0, 1152, 1408, 1728, 1984, 2112, 2176, 2304, 2432, 2496, 2624, 2688, 2752, 2816, 2880, 2944, 3008, 3072, 3136, 3200, 3264, 3328, 3392, 3456, 3520, 4160, 5568, 5824, 5952, 6016, 6336, 6400, 6464, 6720, 6784, 6912, 7104, 7168, 7488, 7680, 8256, 8512, 8640, 8704, 8832, 8896, 8960, 9024, 9152, 9216, 9280, 9408, 9472, 9536, 9600, 9792, 10048, 10112, 10240, 10304, 10432, 10496, 10560, 11328, 11776, 11968, 12160, 12672, 12736, 12800, 12928, 15808, 16384, 16640, 16768, 17024, 17152, 17216, 17280, 17344, 17536, 17600, 18624, 21120, 21312, 21376, 21696, 21760, 21824, 21888, 21952, 22016, 22080, 22144, 24128, 24320, 24448, 24576, 24768, 24832, 24896, 24960, 25024, 25088, 25152, 25216, 27008, 29504, 30336, 31104, 31168, 31296, 31360, 31488, 31552, 31616, 34624, 35200, 35328, 35968, 36416, 36544, 36608, 36672, 37248, 37312, 38336, 40384, 40512, 40896, 40960, 41536, 41600, 41664, 41728, 41792, 41984, 42048, 43712, 44544, 45952, 46144, 46848, 46976, 47360, 47424, 47488, 47552, 47616, 47680, 47744, 47872, 47936, 48256, 49024, 49088, 49152, 49216, 49280, 49344, 49408, 50112, 50688, 50752, 50880, 51136, 51200, 51264, 51328, 52352, 54400, 54464, 54528, 54592, 54656, 54912, 54976, 55040, 55104, 55168, 55680, 56256, 56448, 56576, 56640, 56704, 56768, 57024, 57088, 57152, 57216, 57280, 57600, 58368, 58432, 58496, 58560, 58624, 58688, 58752, 58816, 58880, 58944, 59008, 59072, 59136, 59200, 59264, 59328, 59392, 59456, 59520, 59584, 61248, 61440, 61824, 62144, 62272, 62336, 62464, 62528, 62592, 62784, 62848, 64512, 66560, 67072, 67264, 67392, 67840, 67968, 68096, 68480, 68608, 68800, 68992, 69056, 69120, 69184, 69248, 69312, 69376, 69440, 69504, 69568, 69632, 69696, 69760, 69824, 69888, 70336, 70464, 71232, 71616, 71744, 71872, 72000, 72128, 72192, 72256, 72320, 72384, 72448, 72576, 72640, 72704, 72768, 72832, 72896, 72960, 73024, 73088, 73152, 73216, 73280, 73344, 73408, 73472, 73536, 73600, 73792, 74176, 74240, 74432, 74496, 74624, 74688, 74752, 76032, 76480, 76736, 76992, 77632, 77696, 77760, 77952, 82176, 82624, 82944, 83072, 83392, 83456, 83520, 83584, 83648, 83904, 83968, 86848, 90496, 90944, 91008, 91456, 91520, 91584, 91648, 91712, 91840, 91968, 92032, 94912, 95168, 95296, 95424, 95680, 95744, 95808, 95872, 95936, 96000, 96064, 96128, 98944, 100992, 102080, 103168, 103232, 103360, 103424, 103552, 103616, 103680, 108032, 108480, 108608, 109376, 109952, 110016, 110080, 110144, 110976, 111040, 113920, 116864, 117056, 117824, 117888, 118720, 118784, 118848, 118976, 119104, 119360, 119424, 122240, 123008, 124992, 125248, 126144, 126208, 126784, 126848, 126912, 126976, 127040, 127104, 127168, 127296, 127360, 127744, 128832, 128896, 129024, 129088, 129216, 129280, 129344, 130304, 130752, 130816, 130880, 131200, 131264, 131328, 131392, 134272, 137216, 137280, 137344, 137408, 137472, 137856, 137920, 138048, 138112, 138176, 138624, 139456, 139712, 139776, 139840, 139904, 139968, 140352, 140416, 140480, 140544, 140608, 140992, 142080, 142144, 142272, 142336, 142464, 142528, };

extern "C" __global__ void initializeRNGKernel(unsigned long long deviceRNGSeed) {
    if(threadIdx.x == 0) {
        curand_init(deviceRNGSeed, 0, 0, &d_rng);
    }
}

extern "C" __global__ void initializeKernel(unsigned long long deviceRNGSeed) {
    const unsigned int id = 32 * blockIdx.x + threadIdx.x;
    // ------------------------------------------------------------------------
    // Local neuron groups
    // merged0
    if(id < 3328) {
        unsigned int lo = 0;
        unsigned int hi = 2;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID0[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup0 *group = &d_mergedNeuronInitGroup0[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID0[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
            // current source variables
        }
    }
    // merged1
    if(id >= 3328 && id < 16832) {
        struct MergedNeuronInitGroup1 *group = &d_mergedNeuronInitGroup1[0]; 
        const unsigned int lid = id - 3328;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
            // current source variables
        }
    }
    // merged2
    if(id >= 16832 && id < 18592) {
        struct MergedNeuronInitGroup2 *group = &d_mergedNeuronInitGroup2[0]; 
        const unsigned int lid = id - 16832;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
             {
                group->inSynInSyn13[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn13[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn13 = 0;
                }
            }
             {
                group->inSynInSyn14[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn14[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn14 = 0;
                }
            }
             {
                group->inSynInSyn15[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn15[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn15 = 0;
                }
            }
             {
                group->inSynInSyn16[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn16[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn16 = 0;
                }
            }
            // current source variables
        }
    }
    // merged3
    if(id >= 18592 && id < 60288) {
        unsigned int lo = 0;
        unsigned int hi = 2;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID3[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup3 *group = &d_mergedNeuronInitGroup3[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID3[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
             {
                group->inSynInSyn13[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn13[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn13 = 0;
                }
            }
            // current source variables
        }
    }
    // merged4
    if(id >= 60288 && id < 77792) {
        unsigned int lo = 0;
        unsigned int hi = 3;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID4[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup4 *group = &d_mergedNeuronInitGroup4[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID4[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
            // current source variables
        }
    }
    // merged5
    if(id >= 77792 && id < 162848) {
        unsigned int lo = 0;
        unsigned int hi = 6;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID5[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup5 *group = &d_mergedNeuronInitGroup5[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID5[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
            // current source variables
        }
    }
    // merged6
    if(id >= 162848 && id < 174880) {
        unsigned int lo = 0;
        unsigned int hi = 5;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID6[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup6 *group = &d_mergedNeuronInitGroup6[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID6[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
            // current source variables
        }
    }
    // merged7
    if(id >= 174880 && id < 205344) {
        unsigned int lo = 0;
        unsigned int hi = 6;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID7[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup7 *group = &d_mergedNeuronInitGroup7[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID7[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
            // current source variables
        }
    }
    // merged8
    if(id >= 205344 && id < 300192) {
        unsigned int lo = 0;
        unsigned int hi = 2;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID8[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup8 *group = &d_mergedNeuronInitGroup8[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID8[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
             {
                group->inSynInSyn13[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn13[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn13 = 0;
                }
            }
             {
                group->inSynInSyn14[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn14[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn14 = 0;
                }
            }
             {
                group->inSynInSyn15[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn15[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn15 = 0;
                }
            }
            // current source variables
        }
    }
    // merged9
    if(id >= 300192 && id < 321824) {
        struct MergedNeuronInitGroup9 *group = &d_mergedNeuronInitGroup9[0]; 
        const unsigned int lid = id - 300192;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
             {
                group->inSynInSyn13[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn13[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn13 = 0;
                }
            }
             {
                group->inSynInSyn14[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn14[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn14 = 0;
                }
            }
             {
                group->inSynInSyn15[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn15[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn15 = 0;
                }
            }
             {
                group->inSynInSyn16[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn16[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn16 = 0;
                }
            }
             {
                group->inSynInSyn17[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn17[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn17 = 0;
                }
            }
            // current source variables
        }
    }
    // merged10
    if(id >= 321824 && id < 384576) {
        unsigned int lo = 0;
        unsigned int hi = 5;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID10[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup10 *group = &d_mergedNeuronInitGroup10[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID10[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
             {
                group->inSynInSyn13[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn13[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn13 = 0;
                }
            }
             {
                group->inSynInSyn14[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn14[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn14 = 0;
                }
            }
            // current source variables
        }
    }
    
    // ------------------------------------------------------------------------
    // Synapse groups
    
    // ------------------------------------------------------------------------
    // Custom update groups
    
    // ------------------------------------------------------------------------
    // Custom WU update groups
    
    // ------------------------------------------------------------------------
    // Synapse groups with sparse connectivity
    // merged0
    if(id >= 384576 && id < 6775488) {
        unsigned int lo = 0;
        unsigned int hi = 424;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedSynapseConnectivityInitGroupStartID0[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedSynapseConnectivityInitGroup0 *group = &d_mergedSynapseConnectivityInitGroup0[lo - 1]; 
        const unsigned int groupStartID = d_mergedSynapseConnectivityInitGroupStartID0[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing presynaptic neurons
        if(lid < group->numSrcNeurons) {
            group->rowLength[lid] = 0;
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            // Build sparse connectivity
            scalar x = 0.00000000000000000e+00f;
            unsigned int c = group->preCalcRowLength[(lid * 1) + 0];
            while(true) {
                if(c == 0) {
                   break;
                }
                const scalar u = curand_uniform(&localRNG);
                x += (1.0f - x) * (1.0f - pow(u, 1.0f / (scalar)c));
                unsigned int postIdx = (unsigned int)(x * group->numTrgNeurons);
                postIdx = (postIdx < group->numTrgNeurons) ? postIdx : (group->numTrgNeurons - 1);
                do {
                    const unsigned int idx = (lid * group->rowStride) + group->rowLength[lid];
                    group->ind[idx] = postIdx+0;
                    group->rowLength[lid]++;
                }
                while(false);
                c--;
                
            }
        }
    }
    
}

__device__ int finishedBlockCounter = 0; // 全局变量，记录完成的 block 数量
extern "C" __global__ void initializeSparseKernel() {
    const unsigned int id = 64 * blockIdx.x + threadIdx.x;
    __shared__ unsigned int shRowLength[64];
    // merged0
    if(id < 142592) {
        unsigned int lo = 0;
        unsigned int hi = 424;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedSynapseSparseInitGroupStartID0[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedSynapseSparseInitGroup0 *group = &d_mergedSynapseSparseInitGroup0[lo - 1]; 
        const unsigned int groupStartID = d_mergedSynapseSparseInitGroupStartID0[lo - 1];
        const unsigned int lid = id - groupStartID;
        curandStatePhilox4_32_10_t localRNG = d_rng;
        skipahead_sequence((unsigned long long)6775488 + id, &localRNG);
        const unsigned int numBlocks = (group->numSrcNeurons + 64 - 1) / 64;
        unsigned int idx = lid;
        if(id == 0) {
            printf("blockIdx: %d, numBlocks: %d\n", blockIdx.x, numBlocks);
        }
        for(unsigned int r = 0; r < numBlocks; r++) {
            // if(id==0){
            //     printf("first thread, the %d-th block of total %d blocks\n", r, numBlocks);
            // }
            const unsigned numRowsInBlock = (r == (numBlocks - 1)) ? ((group->numSrcNeurons - 1) % 64) + 1 : 64;// ������ΪnumSrcNeurons+1
            __syncthreads();
            if (threadIdx.x < numRowsInBlock) {
                shRowLength[threadIdx.x] = group->rowLength[(r * 64) + threadIdx.x];
            __syncthreads();
            for(unsigned int i = 0; i < numRowsInBlock; i++) {
                if(lid < shRowLength[i]) {
                     {
                        scalar initVal;
                        scalar normal;
                        do
                        {
                           normal = group->meang + (curand_normal(&localRNG) * group->sdg);
                        } while (normal > (3.40282346638528860e+38f) || normal < (0.00000000000000000e+00f));
                        initVal = normal;
                        
                        group->g[(((r * 64) + i) * group->rowStride) + lid] = initVal;
                    }
                     {
                        uint8_t initVal;
                        scalar normal;
                        do
                        {
                           normal = group->meanTimestepd + (curand_normal(&localRNG) * group->sdTimestepd);
                        } while (normal > group->maxTimestepd || normal < (0.00000000000000000e+00f));
                        initVal = rint(normal);
                        
                        group->d[(((r * 64) + i) * group->rowStride) + lid] = initVal;
                    }
                }
                idx += group->rowStride;
            }
        }
        __syncthreads();
        if(threadIdx.x==0){
            int finished = atomicAdd(&finishedBlockCounter, 1);
            printf("initializeSparseKernel %d-th block finished. Total finished: %d\n", blockIdx.x, finished + 1);
        }
    }
}
void initialize() {
    unsigned long long deviceRNGSeed = 0;
    deviceRNGSeed = 3999352308;
    initializeRNGKernel<<<1, 1>>>(deviceRNGSeed);
    CHECK_CUDA_ERRORS(cudaPeekAtLastError());
     {
        CHECK_CUDA_ERRORS(cudaEventRecord(initStart));
        const dim3 threads(32, 1);
        const dim3 grid(211734, 1);
        initializeKernel<<<grid, threads>>>(deviceRNGSeed);
        CHECK_CUDA_ERRORS(cudaPeekAtLastError());
        CHECK_CUDA_ERRORS(cudaDeviceSynchronize());
        std::cout << "device sync" << std::endl;
        CHECK_CUDA_ERRORS(cudaEventRecord(initStop));
        CHECK_CUDA_ERRORS(cudaEventSynchronize(initStop));
        std::cout << "Event sync" << std::endl;
        float tmp;
        CHECK_CUDA_ERRORS(cudaEventElapsedTime(&tmp, initStart, initStop));
        initTime += tmp / 1000.0;
    }
}

void initializeSparse() {
    copyStateToDevice(true);
    copyConnectivityToDevice(true);
    
     {
        CHECK_CUDA_ERRORS(cudaEventRecord(initSparseStart));
        const dim3 threads(64, 1);
        const dim3 grid(2228, 1);
        initializeSparseKernel<<<grid, threads>>>();
        CHECK_CUDA_ERRORS(cudaPeekAtLastError());
        std::cout << "check error" << std::endl;
        cudaError_t err = cudaDeviceSynchronize();
        if (err != cudaSuccess) {
            std::cout << "cudaDeviceSynchronize Error: " << cudaGetErrorString(err) << std::endl;
        }
        std::cout << "device sync" << std::endl;
        CHECK_CUDA_ERRORS(cudaEventRecord(initSparseStop));
        CHECK_CUDA_ERRORS(cudaEventSynchronize(initSparseStop));
        float tmp;
        CHECK_CUDA_ERRORS(cudaEventElapsedTime(&tmp, initSparseStart, initSparseStop));
        initSparseTime += tmp / 1000.0;
    }
}
